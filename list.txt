aggregates like AVG, COUNT, etc. DONE

SELECT 'abc'; DONE
SELECT '456' + 1; DONE
SELECT CAST('123' AS INTEGER); DONE 

SELECT 'Hello, SQLite!' AS greeting;" 
SELECT CAST("0x1A2B" AS INTEGER); DONE

SELECT printf("%d", 0x1A2B); DONE

CREATE VIRTUAL TABLE my_rtree USING rtree(id, minX, maxX, minY, maxY);
INSERT INTO my_rtree VALUES (1, 0.0, 5.0, 0.0, 5.0);
INSERT INTO my_rtree VALUES (2, 4.0, 6.0, 4.0, 6.0);
SELECT id FROM my_rtree
WHERE minX <= 5.0 AND maxX >= 2.0
  AND minY <= 5.0 AND maxY >= 2.0;
DELETE FROM my_rtree WHERE id = 1;

CREATE VIRTUAL TABLE docs USING fts4(title, body);
SELECT * FROM json_each('{"a":1,"b":2}');
SELECT * FROM json_tree('{"a": 1, "b": {"c": 2}, "d": [10, 20]}');

CREATE VIRTUAL TABLE emails USING fts4(subject, body);
INSERT INTO emails (subject, body) VALUES ('hello', 'how are you?');
SELECT * FROM emails WHERE emails MATCH 'hello';

CREATE VIRTUAL TABLE dbstat USING dbstat;
SELECT name, path, pageno FROM dbstat WHERE name='your_table_name';

CREATE TABLE docs(id INTEGER PRIMARY KEY, data TEXT);
INSERT INTO docs(data) VALUES ('{"name":"Alice","age":30,"skills":["SQL","C"]}');
SELECT jt.key, jt.value
FROM docs, json_tree(docs.data) AS jt
WHERE jt.type = 'text';

CREATE TABLE t(x INTEGER);
INSERT INTO t VALUES (1), (2), (3), ..., (1000);
ANALYZE;
SELECT * FROM t WHERE x = 500;

CREATE TABLE t(x);
INSERT INTO t(x) VALUES(:myparam);

BEGIN; COMMIT; ROLLBACK;

# does not work from coverage_test
.open test.db
.exit

# 100MB, maybe for unix file-system?
PRAGMA mmap_size = 104857600;

# BLOB: maybe but don't really need it (only small increase)
CREATE TABLE t(x BLOB);
INSERT INTO t VALUES (zeroblob(1000000));
SELECT length(x) FROM t;

# boolean type: not sure if that matters, small increase in coverage
BOOLEAN
TRUE, FALSE

CREATE TABLE t(x);  -- so here we see that maybe we should add Expressions as part of random value generation (probably just wiht the flag no_cols)
INSERT INTO t VALUES(1+2);
UPDATE t SET x = x*2;


SELECT length('hello'); DONE
SELECT lower('HELLO');    DONE  
SELECT upper('hello');   DONE
SELECT trim('  hello  ');  DONE
SELECT ltrim('  hello');   DONE    
SELECT rtrim('hello  ');   DONE 
SELECT replace('hello world', 'world', 'SQLite'); DONE
SELECT substr('SQLite', 2, 3);   DONE
SELECT instr('hello world', 'world');  DONE 
SELECT printf('Hello, %s!', 'World');  DONE
SELECT hex('abc');     DONE                 
SELECT char(65, 66, 67);                 
SELECT unicode('Ã‰');                      
SELECT quote('hello');   DONE 

SELECT abs(-42);            DONE              
SELECT round(3.14159);      DONE         
SELECT round(3.14159, 2);   DONE          
SELECT random();                    
SELECT length(randomblob(4));   
SELECT total(value) FROM (SELECT NULL as value);

SELECT ifnull(NULL, 'fallback');     
SELECT ifnull('value', 'fallback');     
SELECT nullif(5, 5);                
SELECT nullif(5, 6);          
SELECT coalesce(NULL, NULL, 'first non-null');
SELECT typeof(123);     DONE     
SELECT typeof(3.14);      DONE          
SELECT typeof('abc');    DONE         
SELECT typeof(NULL);


What about dropping tables, views, and columns?