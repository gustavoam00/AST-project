DONE:
aggregates like AVG, COUNT, etc.
SELECT 'abc';
SELECT '456' + 1;
SELECT CAST("0x1A2B" AS INTEGER);
SELECT printf("%d", 0x1A2B);
SELECT CAST('123' AS INTEGER);
PRAGMA mmap_size = 104857600;
SELECT length('hello');
SELECT lower('HELLO');
SELECT upper('hello');
SELECT trim('  hello  ');
SELECT ltrim('  hello');
SELECT rtrim('hello  ');
SELECT replace('hello world', 'world', 'SQLite');
SELECT substr('SQLite', 2, 3);
SELECT instr('hello world', 'world');
SELECT printf('Hello, %s!', 'World');
SELECT hex('abc');
SELECT quote('hello');
SELECT abs(-42);
SELECT round(3.14159);
SELECT round(3.14159, 2);
SELECT typeof(123);
SELECT typeof(3.14);
SELECT typeof('abc');
SELECT typeof(NULL);
SELECT coalesce(NULL, NULL, 'first non-null');    
SELECT ifnull(NULL, 'fallback');     
SELECT ifnull('value', 'fallback');   
BOOLEAN: TRUE, FALSE 
SELECT char(65, 66, 67);  
SELECT unicode('Ã‰'); 
SELECT random();  
SELECT nullif(5, 5);                
SELECT nullif(5, 6);
BEGIN; COMMIT; ROLLBACK;~SAVEPOINTS
INSERT INTO t VALUES(1+2);
UPDATE t SET x = x*2;
SELECT total(value) FROM (SELECT NULL as value);
INSERT INTO t(x) VALUES(:myparam);   

CREATE TABLE t(x INTEGER);
INSERT INTO t VALUES (1), (2), (3), ..., (1000);
ANALYZE;
SELECT * FROM t WHERE x = 500;

TODO:

SELECT 'Hello, SQLite!' AS greeting;

CREATE VIRTUAL TABLE my_rtree USING rtree(id, minX, maxX, minY, maxY);
INSERT INTO my_rtree VALUES (1, 0.0, 5.0, 0.0, 5.0);
INSERT INTO my_rtree VALUES (2, 4.0, 6.0, 4.0, 6.0);
SELECT id FROM my_rtree
WHERE minX <= 5.0 AND maxX >= 2.0
  AND minY <= 5.0 AND maxY >= 2.0;
DELETE FROM my_rtree WHERE id = 1;

CREATE VIRTUAL TABLE docs USING fts4(title, body);
SELECT * FROM json_each('{"a":1,"b":2}');
SELECT * FROM json_tree('{"a": 1, "b": {"c": 2}, "d": [10, 20]}');

CREATE VIRTUAL TABLE emails USING fts4(subject, body);
INSERT INTO emails (subject, body) VALUES ('hello', 'how are you?');
SELECT * FROM emails WHERE emails MATCH 'hello';

CREATE VIRTUAL TABLE dbstat USING dbstat;
SELECT name, path, pageno FROM dbstat WHERE name='your_table_name';

CREATE TABLE docs(id INTEGER PRIMARY KEY, data TEXT);
INSERT INTO docs(data) VALUES ('{"name":"Alice","age":30,"skills":["SQL","C"]}');
SELECT jt.key, jt.value
FROM docs, json_tree(docs.data) AS jt
WHERE jt.type = 'text';

# does not work from coverage_test
.open test.db
.exit
.parameter?
           

What about dropping tables, views, and columns?

functions from PRAGMA function_list;
group_concat|1
julianday|1
ntile|1
nullif|1
sqlite_compileoption_get|1
current_timestamp|1
sqlite_compileoption_used|1
sum|1
quote|1
printf|1
likelihood|1
last_value|1
rank|1
round|1
rtrim|1
nth_value|1
random|1
trim|1
time|1
total|1
substr|1
replace|1
upper|1
typeof|1
load_extension|1
avg|1
abs|1
strftime|1
unknown|1
randomblob|1
unicode|1
percent_rank|1
row_number|1
last_insert_rowid|1
sqlite_log|1
unlikely|1
char|1
count|1
date|1
sqlite_offset|1
total_changes|1
changes|1
sqlite_version|1
coalesce|1
glob|1
zeroblob|1
hex|1
sqlite_source_id|1
datetime|1
cume_dist|1
instr|1
dense_rank|1
ifnull|1
current_date|1
current_time|1
lag|1
like|1
max|1
min|1
lead|1
lower|1
ltrim|1
first_value|1
length|1
likely|1
shell_add_schema|0
lsmode|0
readfile|0
shell_putsnl|0
json_replace|0
writefile|0
json_type|0
json_remove|0
json_quote|0
json_group_object|0
json_extract|0
json_group_array|0
json_array|0
edit|0
json|0
json_set|0
json_patch|0
match|0
json_insert|0
fts3_tokenizer|0
snippet|0
offsets|0
shell_module_schema|0
json_valid|0
matchinfo|0
json_array_length|0
optimize|0
sha3|0
rtreedepth|0
sha3_query|0
json_object|0
rtreenode|0
rtreecheck|0